// Code generated by sheeter. DO NOT EDIT.
// Sheeter: https://github.com/yinweli/Sheeter

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;

namespace Sheeter
{
    /// <summary>
    /// 裝載器介面
    /// </summary>
    public interface Loader
    {
        /// <summary>
        /// 讀取檔案, 實作時須注意必須維持執行緒安全
        /// </summary>
        public string Load(FileName filename);

        /// <summary>
        /// 錯誤處理, 實作時須注意必須維持執行緒安全
        /// </summary>
        public void Error(string name, string message);
    }

    /// <summary>
    /// 讀取器介面
    /// </summary>
    public interface Reader
    {
        /// <summary>
        /// 取得檔名物件
        /// </summary>
        public FileName FileName();

        /// <summary>
        /// 讀取資料
        /// </summary>
        public string FromData(string data, bool clear, Progress progress);

        /// <summary>
        /// 清除資料
        /// </summary>
        public void Clear();
    }

    /// <summary>
    /// 字串解析組件
    /// </summary>
    public static class Parse
    {
        /// <summary>
        /// 解析函式類型
        /// </summary>
        public delegate (object? obj, bool ok) Parser(string value);

        /// <summary>
        /// 字串解析結果
        /// </summary>
        public class Result
        {
            public Result(object? value, string error = "")
            {
                this.value = value;
                this.error = error ?? string.Empty;
            }

            /// <summary>
            /// 取得結果物件
            /// </summary>
            public object? Value()
            {
                return value;
            }

            /// <summary>
            /// 取得結果物件, 會丟出例外
            /// </summary>
            public T ValueAs<T>()
            {
                if (string.IsNullOrEmpty(error) == false)
                    throw new InvalidOperationException(error);

                if (value is not T result)
                {
                    var actual = value is null ? "null" : value.GetType().ToString();
                    var expect = typeof(T).ToString();
                    throw new InvalidCastException($"value is {actual} not {expect}");
                } // if

                return result;
            }

            /// <summary>
            /// 取得結果物件, 不會丟出例外
            /// </summary>
            public bool TryValue<T>(out T value)
            {
                if (string.IsNullOrEmpty(error) == false || this.value is not T result)
                {
                    value = default!;
                    return false;
                } // if

                value = result;
                return true;
            }

            /// <summary>
            /// 取得錯誤訊息
            /// </summary>
            public string Error()
            {
                return error;
            }

            public static implicit operator bool(Result obj)
            {
                return obj is not null && string.IsNullOrEmpty(obj.error);
            }

            /// <summary>
            /// 結果物件
            /// </summary>
            private readonly object? value;

            /// <summary>
            /// 錯誤訊息
            /// </summary>
            private readonly string error = string.Empty;
        }

        static Parse()
        {
            AddParse<int>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (int.TryParse(value, out int result))
                    return (result, true);

                return (default, false);
            });
            AddParse<long>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (long.TryParse(value, out long result))
                    return (result, true);

                return (default, false);
            });
            AddParse<float>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (float.TryParse(value, out float result))
                    return (result, true);

                return (default, false);
            });
            AddParse<double>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (double.TryParse(value, out double result))
                    return (result, true);

                return (default, false);
            });
            AddParse<string>(value =>
            {
                return (value, true);
            });
            AddParse<Ratio>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (value.Length == 0)
                    return (new Ratio("0"), true);

                if (double.TryParse(value, out _) == false)
                    return (default, false);

                return (new Ratio(value), true);
            });
            AddParse<Duration>(value =>
            {
                value = (value ?? string.Empty).Trim();

                if (value.Length == 0)
                    return (new Duration("0s"), true);

                if (Duration.parse(value, out _) == false)
                    return (default, false);

                return (new Duration(value), true);
            });
        }

        /// <summary>
        /// 新增解析
        /// </summary>
        public static void AddParse<T>(Parser parser)
        {
            @lock.EnterWriteLock();

            try
            {
                parse[typeof(T)] = parser;
            } // try
            finally
            {
                @lock.ExitWriteLock();
            } // finally
        }

        /// <summary>
        /// 執行解析
        /// </summary>
        public static Result RunParse<T>(string value)
        {
            @lock.EnterReadLock();

            try
            {
                var type = typeof(T);

                if (parse.TryGetValue(type, out var parser) == false || parser == null)
                    return new Result(null, $"{type} not exist");

                var result = parser(value);

                if (result.ok == false)
                    return new Result(null, $"{type} parse failed");

                return new Result(result.obj);
            } // try
            finally
            {
                @lock.ExitReadLock();
            } // finally
        }

        /// <summary>
        /// 字串擴充: 執行解析
        /// </summary>
        public static Result Parses<T>(this string value)
        {
            return RunParse<T>(value);
        }

        /// <summary>
        /// 字串擴充: 執行解析, 會丟出例外
        /// </summary>
        public static T ParseAs<T>(this string value)
        {
            return RunParse<T>(value).ValueAs<T>();
        }

        /// <summary>
        /// 字串擴充: 執行解析, 不會丟出例外
        /// </summary>
        public static bool TryParse<T>(this string value, out T result)
        {
            return RunParse<T>(value).TryValue(out result);
        }

        /// <summary>
        /// 字串列表擴充: 執行解析
        /// </summary>
        public static Result[] Parses<T>(this string[] value)
        {
            return value.Select(itor => RunParse<T>(itor)).ToArray();
        }

        /// <summary>
        /// 字串列表擴充: 執行解析, 會丟出例外
        /// </summary>
        public static T[] ParseAs<T>(this string[] value)
        {
            return value.Select(itor => RunParse<T>(itor).ValueAs<T>()).ToArray();
        }

        /// <summary>
        /// 字串列表擴充: 執行解析, 不會丟出例外
        /// </summary>
        public static bool TryParse<T>(this string[] value, out T[] result)
        {
            var ok = false;
            var list = new List<T>();

            foreach (var itor in value)
            {
                if (RunParse<T>(itor).TryValue(out T v))
                    list.Add(v);
                else
                    ok = false;
            } // for

            result = list.ToArray();
            return ok;
        }

        /// <summary>
        /// 解析列表
        /// </summary>
        private static readonly Dictionary<Type, Parser> parse = new();

        /// <summary>
        /// 解析執行緒鎖
        /// </summary>
        private static readonly ReaderWriterLockSlim @lock = new();
    }

    /// <summary>
    /// 檔名資料
    /// </summary>
    public class FileName
    {
        public FileName(string name, string ext)
        {
            this.name = name;
            this.ext = ext;
        }

        /// <summary>
        /// 取得名稱
        /// </summary>
        public string Name
        {
            get { return name; }
        }

        /// <summary>
        /// 取得副檔名
        /// </summary>
        public string Ext
        {
            get { return ext; }
        }

        /// <summary>
        /// 取得完整檔名
        /// </summary>
        public string File
        {
            get { return name + ext; }
        }

        /// <summary>
        /// 名稱
        /// </summary>
        private readonly string name;

        /// <summary>
        /// 副檔名
        /// </summary>
        private readonly string ext;
    }

    /// <summary>
    /// 進度資料
    /// </summary>
    public class Progress
    {
        /// <summary>
        /// 重置進度
        /// </summary>
        public void Reset()
        {
            @lock.EnterWriteLock();

            try
            {
                done = false;
                task = 0;
                data.Clear();
            } // try
            finally
            {
                @lock.ExitWriteLock();
            } // finally
        }

        /// <summary>
        /// 完成進度
        /// </summary>
        public void Complete()
        {
            @lock.EnterWriteLock();

            try
            {
                done = true;
            } // try
            finally
            {
                @lock.ExitWriteLock();
            } // finally
        }

        /// <summary>
        /// 註冊進度
        /// </summary>
        public int Reg()
        {
            @lock.EnterWriteLock();

            try
            {
                task++;
                data[task] = 0.0f;
                return task;
            } // try
            finally
            {
                @lock.ExitWriteLock();
            } // finally
        }

        /// <summary>
        /// 設定進度
        /// </summary>
        public void Set(int task, int curr, int total)
        {
            @lock.EnterWriteLock();

            try
            {
                var value = 0.0f;

                if (curr <= 0 || total <= 0)
                    value = 0.0f;
                else if (curr >= total)
                    value = 1.0f;
                else
                    value = (float)curr / total;

                data[task] = value;
            } // try
            finally
            {
                @lock.ExitWriteLock();
            } // finally
        }

        /// <summary>
        /// 取得進度, 進度值為 0 ~ 1 的浮點數
        /// </summary>
        public float Get()
        {
            @lock.EnterReadLock();

            try
            {
                if (done)
                    return 1.0f;

                if (data.Count == 0)
                    return 0.0f;

                var curr = 0.0f;

                foreach (var itor in data.Values)
                    curr += itor;

                return curr / data.Count;
            } // try
            finally
            {
                @lock.ExitReadLock();
            } // finally
        }

        /// <summary>
        /// 完成旗標
        /// </summary>
        private bool done = false;

        /// <summary>
        /// 進度編號
        /// </summary>
        private int task = 0;

        /// <summary>
        /// 進度列表
        /// </summary>
        private readonly Dictionary<int, float> data = new();

        /// <summary>
        /// 執行緒鎖
        /// </summary>
        private readonly ReaderWriterLockSlim @lock = new();
    }

    /// <summary>
    /// 比例類型
    /// </summary>
    public readonly struct Ratio
    {
        public Ratio(string value)
        {
            this.value = (value ?? string.Empty).Trim();
        }

        /// <summary>
        /// 取得浮點數
        /// </summary>
        public float Float32()
        {
            return float.TryParse(value, out var result) ? result : 0;
        }

        /// <summary>
        /// 取得浮點數
        /// </summary>
        public double Float64()
        {
            return double.TryParse(value, out var result) ? result : 0;
        }

        /// <summary>
        /// 取得字串
        /// </summary>
        public override string ToString()
        {
            return value;
        }

        /// <summary>
        /// 以基準值計算比例值
        /// </summary>
        public int RatioInt32(int @base)
        {
            return (int)ratio(@base);
        }

        /// <summary>
        /// 以基準值計算比例值
        /// </summary>
        public long RatioInt64(int @base)
        {
            return ratio(@base);
        }

        /// <summary>
        /// 以基準值計算比例值
        /// </summary>
        private long ratio(int @base)
        {
            if (@base <= 0)
                return 0;

            if (decimal.TryParse(value, out var result) == false)
                return 0;

            try
            {
                return (long)decimal.Truncate(result * @base);
            } // try
            catch (OverflowException)
            {
                return 0;
            } // catch
        }

        /// <summary>
        /// 比例字串
        /// </summary>
        private readonly string value;
    }

    /// <summary>
    /// 時長類型
    /// </summary>
    public readonly struct Duration
    {
        public Duration(string value)
        {
            this.value = (value ?? string.Empty).Trim();
        }

        /// <summary>
        /// 取得時長
        /// </summary>
        public TimeSpan Interval()
        {
            return parse(value, out var result) ? result : TimeSpan.Zero;
        }

        /// <summary>
        /// 取得字串
        /// </summary>
        public override string ToString()
        {
            return value;
        }

        /// <summary>
        /// 時長字串
        /// </summary>
        private readonly string value;

        /// <summary>
        /// 解析時長
        /// </summary>
        internal static bool parse(string input, out TimeSpan result)
        {
            result = TimeSpan.Zero;

            var s = (input ?? string.Empty).Trim();
            var sign = 1;

            if (s.StartsWith("-", StringComparison.Ordinal))
            {
                sign = -1;
                s = s.Substring(1).TrimStart();
            } // if

            while (s.Length > 0)
            {
                var match = regex.Match(s);

                if (match.Success == false)
                {
                    if (string.IsNullOrWhiteSpace(s)) // 如果剩下的都是空白, 表示解析完成
                        break;

                    return false;
                } // if

                var value = match.Groups[1].Value;

                if (long.TryParse(value, out var number) == false)
                    return false;

                var unit = match.Groups[2].Value.ToLowerInvariant();

                switch (unit)
                {
                    case "d":
                        result += TimeSpan.FromDays(number);
                        break;

                    case "h":
                        result += TimeSpan.FromHours(number);
                        break;

                    case "m":
                        result += TimeSpan.FromMinutes(number);
                        break;

                    case "s":
                        result += TimeSpan.FromSeconds(number);
                        break;

                    case "ms":
                        result += TimeSpan.FromMilliseconds(number);
                        break;

                    default:
                        return false;
                } // switch

                s = s[match.Length..];
            } // while

            if (sign < 0)
                result = -result;

            return true;
        }

        /// <summary>
        /// 時長正則表達式
        /// </summary>
        internal static readonly Regex regex = new Regex(
            @"^\s*(\d+)\s*(ms|s|m|h|d)",
            RegexOptions.IgnoreCase | RegexOptions.Compiled
        );
    }
}
