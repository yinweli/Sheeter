package builds

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/yinweli/Sheeter/internal/util"
)

// json-cs讀取器模板代碼
const jsonCsReader = `// generated by {{$.AppName}}, DO NOT EDIT.

namespace {{$.Namespace}} {
    using System;
    using System.Collections.Generic;

    using Newtonsoft.Json;

    public partial class {{$.ReaderName}} {
        public static readonly string JsonPath = "{{$.JsonPath}}";

        public static Dictionary<string, {{$.StructName}}> FromJson(string data) {
            return JsonConvert.DeserializeObject<Dictionary<string, {{$.StructName}}>>(data);
        }
    }
}
`

// OutputJsonCsCode 輸出json-cs代碼
func OutputJsonCsCode(content *Content) error {
	if err := os.MkdirAll(filepath.Dir(content.JsonCsPath()), os.ModePerm); err != nil {
		return fmt.Errorf("%s: output json-cs code failed: %w", content.ShowName(), err)
	} // if

	options := []string{
		"--src", content.SchemaPath(),
		"--src-lang", "json",
		"--out", content.JsonCsPath(),
		"--lang", "cs",
		"--top-level", content.StructName(),
		"--namespace", content.Namespace(),
		"--array-type", "array",
		"--features", "attributes-only",
	}

	if err := util.ShellRun("quicktype", options...); err != nil {
		return fmt.Errorf("%s: output json-cs failed, quicktype error: %w", content.ShowName(), err)
	} // if

	return nil
}

// OutputJsonCsReader 輸出json-cs讀取器, 由於quicktype對於結構命名有不一致的問題, 所以採取資料結構由quicktype執行, 而資料列表由模板執行的方式
func OutputJsonCsReader(content *Content) error {
	if err := util.TmplWrite(content.JsonCsReaderPath(), jsonCsReader, content, content.Bom); err != nil {
		return fmt.Errorf("%s: output json-cs reader failed: %w", content.ShowName(), err)
	} // if

	return nil
}
