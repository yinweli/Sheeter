package builds

import (
	"fmt"
	"os"
	"path"

	"github.com/yinweli/Sheeter/internal/util"
)

// json-c#讀取器模板代碼
const jsonCsReaderCode = `// generated by {{$.Namespace}}, DO NOT EDIT.

namespace {{$.Namespace}} {
    using System;
    using System.Collections.Generic;

    using Newtonsoft.Json;

    public partial class {{$.ReaderName}} {
        public static readonly string JsonFileName = "{{$.JsonFileName}}";

        public static Dictionary<string, {{$.StructName}}> FromJson(string data) {
            return JsonConvert.DeserializeObject<Dictionary<string, {{$.StructName}}>>(data);
        }
    }
}
`

// writeJsonCs 輸出json-c#代碼
func writeJsonCs(content *Content) error {
	if err := os.MkdirAll(path.Dir(content.JsonCsFilePath()), os.ModePerm); err != nil {
		return fmt.Errorf("%s: write json cs failed: %w", content.TargetName(), err)
	} // if

	options := []string{
		"--src", content.SchemaFilePath(),
		"--src-lang", "json",
		"--out", content.JsonCsFilePath(),
		"--lang", "cs",
		"--top-level", content.StructName(),
		"--namespace", content.Namespace(),
		"--array-type", "array",
		"--features", "attributes-only",
	}

	if err := util.ShellRun("quicktype", options...); err != nil {
		return fmt.Errorf("%s: write json cs failed: %w", content.TargetName(), err)
	} // if

	return nil
}

// writeJsonCsReader 輸出json-c#讀取器, 由於quicktype對於結構命名有不一致的問題, 所以採取資料結構由quicktype執行, 而資料列表由模板執行的方式
func writeJsonCsReader(content *Content) error {
	if err := util.TmplWrite(content.JsonCsReaderFilePath(), jsonCsReaderCode, content, content.Bom); err != nil {
		return fmt.Errorf("%s: write json cs reader failed: %w", content.TargetName(), err)
	} // if

	return nil
}
